# Django Network Inventory App – Development Task List

## Project Setup and Configuration

1. [x] **Initialize the Django project.** Create a new Django project and app. Configure **SQLite** for local development and prepare settings for **PostgreSQL** in production (e.g. using environment variables or a separate settings file). Install necessary packages (e.g. `django`, `psycopg2`, `django-environ` or similar). Ensure **Bootstrap CSS** is included (via static files or CDN) for front-end styling.
2. [x] **Set up local authentication.** Use Django’s built-in auth system: implement user registration/login pages (or just admin-created users), password management, and secure login/logout functionality. Restrict to a single-organization context (no multi-tenant logic needed). Skip external OAuth/OIDC for now.
3. [x] **Configure static and media files.** Ensure `STATIC_URL` and `MEDIA_URL` are set, and collect static assets (including Bootstrap) so the app can run on-premises without internet access if needed. Document environment variables and settings for dev vs prod.

## Data Models

4. [x] **Define core models:** Create Django models for **Device (Asset)**, **Interface**, **Connection/Link**, **Tag**, and **AlertProfile**. For example, a *Device* model might have fields for hostname, management IP, vendor, model, OS version, and credentials placeholders (e.g. SNMP community, login). An *Interface* model should link to a Device, storing interface name, MAC, IPs, and status. A *Connection* model (or self-referential many-to-many) should link two Interfaces (device-to-device link) to represent topology edges. Use Django’s ORM relationships (ForeignKey, ManyToMany) to connect these.
5. [x] **Include discovery metadata fields:** Add fields to store discovery data, such as last-seen timestamp, SNMP community string found, SSH credentials (if discovered), and any “roadblocks” (e.g. default usernames/passwords detected). Maintain a history log or timestamp for when each device/interface was last scanned.
6. [x] **Implement tagging and alert profiles:** Use a ManyToManyField for tags on the Device model, allowing admins to categorize assets (e.g. “core-switch”, “printer”, “router”). Create an *AlertProfile* model to store threshold settings (e.g. CPU > 90%, interface down, ping loss). AlertProfiles can link to Devices (or tags) and define metric thresholds for triggering alerts.

## Network Discovery and Inventory Collection

7. [x] **SNMP scanning module:** Implement a discovery routine using Python’s `pysnmp` library to perform SNMP GET/GETNEXT queries. Use SNMP to read system information (`sysDescr`, `sysName`), interface tables (`IF-MIB`), ARP tables (`IP-MIB`, OID `ipNetToMediaTable`), and switch CAM (MAC) tables (`BRIDGE-MIB`). This will gather device details and inventory (interfaces, ARP entries, MAC addresses). Use these queries to create or update Device and Interface records in the database. The SOCS docs note that “SNMP support is provided through the python module pysnmp”, which can be integrated into Django tasks.
8. [x] **CDP/LLDP neighbor discovery:** Use SNMP to retrieve Link Layer Discovery Protocol (LLDP) or Cisco Discovery Protocol (CDP) tables. LLDP is an IEEE standard (802.1AB) that devices use to advertise neighbors; data from LLDP (or Cisco’s CDP) is stored on devices and can be read via SNMP. Query the standard LLDP MIB (`lldpRemTable`) and Cisco CDP MIB (`CISCO-CDP-MIB`) to find connected neighbor device IDs and ports. Use this information to populate the Connection/Link model (linking interfaces of two Devices). For example: “Devices running LLDP… store information of neighboring devices in a local table that can be accessed using SNMP”.
9. [x] **SSH/Telnet queries:** For devices that allow CLI access, use **Netmiko** (built on Paramiko) to run SSH (or Telnet) commands. Netmiko provides device-specific handlers (Cisco IOS, Juniper JunOS, etc.) and simplifies running commands like `show ip interface brief` or `show version`. For example, use Netmiko’s `ConnectHandler` to log in and retrieve interface/IP info or routing tables. This complements SNMP data (e.g. when SNMP is restricted). The Codilime blog notes “Netmiko is an open-source… library designed to interact with a wide range of network devices… Netmiko uses SSH (Paramiko) and supports Telnet”. Write code to parse CLI output (possibly with TextFSM) and update the inventory models.
10. [x] **CAM and ARP tables:** Extend SNMP scanning to gather the switch CAM (MAC address) tables (`dot1dTpFdbTable` from BRIDGE-MIB) and router ARP tables. This helps map which hosts (MAC/IP) are on which switch ports. Use this to enhance topology: if a MAC appears on a switch interface, link that interface to a “Host” asset record.
11. [x] **Organize discovery logic:** Create a recursive or iterative scanning process. Start with a seed IP (e.g. gateway), SNMP walk for neighbors, then scan discovered devices in turn. (The [KaSaNaa/SNMP-Discovery-Script](https://github.com/KaSaNaa/SNMP-Discovery-Script) provides an example: it “recursively discovers devices, their neighbors, and the interfaces they use to connect to each other”.) Adapt this logic into Django-managed tasks: for each new Device found, spawn further SNMP queries until the network is fully mapped. Ensure to handle timeouts and unreachable devices gracefully.
12. [x] **Initial vs periodic scanning:** Distinguish between the **initial discovery** (full network sweep) and **ongoing scans**. The initial scan can be manual or triggered by the admin. Periodic scans (via background job) should update existing records and detect changes (new/removed devices, changed connections).

## Scheduling and Background Tasks

13. [x] **Integrate Celery for async tasks:** Install and configure Celery in the Django project (with a broker like Redis or RabbitMQ). This will allow the heavy network scans to run asynchronously. Use the `@shared_task` decorator or `tasks.py` files for scan functions.
14. [x] **Set up periodic tasks (Celery Beat):** Use Celery Beat to schedule regular rescans of the network. For example, schedule daily or hourly SNMP discovery jobs. The Celery docs explain that “celery beat is a scheduler; it kicks off tasks at regular intervals”. Define entries in the `CELERY_BEAT_SCHEDULE` (or use django-celery-beat) to run tasks like `network_scan`, `metric_poll`, and `alert_check`.
15. [x] **Django management commands:** Optionally create custom Django admin commands (e.g. `python manage.py scan_network`) to trigger scans manually. These commands can call the same logic as the Celery tasks, useful for testing or one-off runs.

## User Interface and Views

16. [x] **Asset listing and detail pages:** Build Bootstrap-styled pages to display the inventory. The **Asset List** page should tabulate devices (name, IP, vendor, type), with search/filter by tag or type. The **Asset Detail** page should show device attributes, interface list, neighbor connections, and current status. Use Bootstrap components (tables, cards) for layout.
17. [x] **Tagging UI:** On the Asset Detail (or list), allow the admin to add/remove tags to assets. Implement a UI (e.g. multiselect dropdown or checkboxes) backed by the Tag model. Support filtering by tag on the Asset List page.
18. [x] **Network topology diagram:** Implemented a view that returns JSON nodes/edges and a topology page using **vis.js** to render the network interactively with pan/zoom.
19. [x] **Charts and graphs:** Added Chart.js to static files and integrated a CPU usage line chart on the device detail page. Created a `MetricRecord` model with a REST API endpoint to return metric data and fetch it via AJAX.
20. [x] **Alerts UI:** Implemented `Alert` model with admin registration and created an alerts page listing active and recent alerts linked to device detail. Navigation updated with an "Alerts" link.

## Monitoring, Metrics, and Alerts

21. [x] **Performance polling:** After discovery, set up ongoing monitoring. Use SNMP to poll key metrics on each device (e.g. CPU and memory utilization, interface in/out octets via `IF-MIB::ifInOctets`/`ifOutOctets`). Schedule these polling tasks via Celery periodically (e.g. every few minutes). Store the results in a time-series table (e.g. Model with timestamp, device, metric, value).
22. [x] **Ping/availability checks:** Implemented a Celery task using `pythonping` to ping each device's management IP. Results are stored as `MetricRecord` entries and down hosts create `Alert` records.
23. [x] **Data storage for history:** Implemented a `MetricRecord` model with an index on device/interface/metric/timestamp to store historical metric values. Added API support for filtering records by date range to keep queries efficient.
24. [x] **Graphing historical data:** Implemented HTMX-driven Chart.js graphs on device and new interface detail pages. Historical CPU and bandwidth metrics are pulled via REST endpoints and rendered dynamically.
25. [x] **Alert evaluation:** In each polling cycle (SNMP or ping), compare metrics against the AlertProfiles. If a threshold is crossed (e.g. CPU > X, interface down, ping lost), create an Alert record. Mark assets with active alerts in the UI. (Notifications can be added later; initially just logging and UI display is sufficient.)
26. [x] **Administration interface:** Registered the key models in Django Admin (Device, Interface, Tag, AlertProfile, Connection, Alert) so admins can manage inventory objects, tags and alert settings via the built-in interface.

## Testing, Documentation, and Deployment

27. [x] **Document setup and usage:** README now includes installation steps, environment variables, how to run scans and what the roadblocks field means.
28. [ ] **Prepare for on-premises deployment:** Ensure all dependencies are installable from internal repos if needed. Configure Django’s `ALLOWED_HOSTS` and security settings for production. Provide a script to install on a local Ubuntu server, so that all packages (both Ubuntu and PIP) are installed.
